{"mappings":"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CoB,IAAA,CACf,YAAc,G,C,G,A,Q,C,C,C,A,C,KACd,IAAA,CAAA,aAAe,G,C,G,A,Q,C,C,C,A,C,KACf,IAAA,CAAA,gBAAkB,E,C,G,A,Q,C,C,C,A,C,KAEM,IAAA,CACxB,UAAY,C,C,G,A,Q,C,C,C,A,C,KACZ,IAAA,CAAA,UAAY,C,C,G,A,Q,C,C,C,A,C,KACZ,IAAA,CAAA,sBAAwB,C,C,G,A,Q,C,C,C,A,C,KACxB,IAAA,CAAA,WAAa,C,C,G,A,Q,C,C,C,A,C,KACiB,IAAA,CAC9B,mBAAqB,C,C,G,A,Q,C,C,C,A,C,KACd,IAAA,CACP,KAAO,E,C,G,A,Q,C,C,C,A,C,KAC2B,IAAA,CAClC,YAAc,E,C,G,A,Q,C,C,C,A,C,KACd,IAAA,CAAA,SAAW,C,C,G,A,Q,C,C,C,A,C,KACU,IAAA,CACrB,aAAe,C,C,G,A,Q,C,C,C,A,C,KACG,IAAA,CAClB,SAAW,E,C,G,A,Q,C,C,C,A,C,KACX,IAAA,CAAA,YAAc,E,C,G,A,Q,C,C,C,A,C,KACwC,IAAA,CACtD,SAAW,G,C,G,A,Q,C,C,C,A,C,KACU,IAAA,CACrB,UAAY,C,C,G,A,Q,C,C,C,A,C,KACc,IAAA,CAC1B,cAAgB,E,C,G,A,Q,C,C,C,A,C,KAChB,IAAA,CAAA,aAAe,E,C,G,A,Q,C,C,C,A,C,KACiC,IAAA,CAChD,gBAAkB,E,C,G,A,Q,C,C,C,A,C,KACL,IAAA,CACb,SAAW,C,C,G,A,Q,C,C,C,A,C,KACX,IAAA,CAAA,eAAiB,C,C,G,AAC5B,CChCA,MAAM,EAWF,aAAc,CACV,IAAI,CAAC,IAAM,EACX,IAAI,CAAC,IAAM,EACX,IAAI,CAAC,IAAM,EACX,IAAI,CAAC,IAAM,EACX,IAAI,CAAC,IAAM,EACX,IAAI,CAAC,IAAM,EACX,IAAI,CAAC,IAAM,EACX,IAAI,CAAC,IAAM,EACX,IAAI,CAAC,IAAM,CACf,CAEQ,cAAc,CAAyB,CAAQ,CACnD,IAAI,CAAC,IAAM,EAAI,IACf,IAAI,CAAC,IAAM,EAAI,IACf,IAAI,CAAC,IAAM,EAAI,IACf,IAAI,CAAC,IAAM,EAAI,IACf,IAAI,CAAC,I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","sources":["<anon>","src/index.ts","src/classes/main.ts","src/classes/timer.ts","src/config.ts","src/classes/controller.ts","src/classes/vector2d.ts","src/classes/geneticAlgorithm.ts","src/classes/mineSweeper.ts","src/classes/neuralNet.ts","src/classes/neuronLayer.ts","src/classes/neuron.ts","src/classes/parameters.ts","src/classes/twoDimensionalMatrix.ts","src/utils/clamp.ts"],"sourcesContent":["(() => {\nconst $323e6d8c0c12152e$export$5162177fdef0d83e = 60;\nconst $323e6d8c0c12152e$export$5753e036582e2d24 = 4;\nconst $323e6d8c0c12152e$export$6fb51cf587721d5c = 1;\nconst $323e6d8c0c12152e$export$c40ba6762188f6b0 = 6;\nconst $323e6d8c0c12152e$export$8c1c414cd78ab8b5 = 2;\nconst $323e6d8c0c12152e$export$8c1d8879bfbdaabd = 1;\nconst $323e6d8c0c12152e$export$545fcf3a97e70662 = -1;\nconst $323e6d8c0c12152e$export$ab9cf40dddefe952 = 0.3;\nconst $323e6d8c0c12152e$export$d4b2493e305275bf = 2;\nconst $323e6d8c0c12152e$export$9d57affa8c541d62 = 5;\nconst $323e6d8c0c12152e$export$f7f03d85ad8d41c5 = 40;\nconst $323e6d8c0c12152e$export$f3f24420e63561d6 = 30;\nconst $323e6d8c0c12152e$export$281869dc3236940 = 2000;\nconst $323e6d8c0c12152e$export$74957bad4521bafe = 2;\nconst $323e6d8c0c12152e$export$e5279d5a2c3f963c = 0.7;\nconst $323e6d8c0c12152e$export$4a7f34cc4a79ff57 = 0.1;\nconst $323e6d8c0c12152e$export$35572e150f3df791 = 0.3;\nconst $323e6d8c0c12152e$export$8e782db2810859d9 = 4;\nconst $323e6d8c0c12152e$export$eaffa1d0ecbd528 = 1;\n\n\nclass $6f7c4b99a861fe4c$var$Timer {\n    constructor(fps = (0, $323e6d8c0c12152e$export$5162177fdef0d83e)){\n        this.currentTime = 0;\n        this.lastTime = 0;\n        this.nextTime = 0;\n        this.frameTime = 0;\n        // this strategy is mostly a byproduct of being a port from C++\n        this.perfCountFreq = 1000; //ms in a second \n        this.timeElapsed = 0;\n        this.fps = 0;\n        if (fps) {\n            this.fps = fps;\n            this.frameTime = this.perfCountFreq / this.fps;\n            this.lastTime = new Date().getTime();\n            this.currentTime = this.lastTime;\n            this.nextTime = this.currentTime + this.frameTime;\n        }\n    }\n    start() {\n        this.nextTime = new Date().getTime() + this.frameTime;\n    }\n    readyForNextFrame() {\n        this.currentTime = new Date().getTime();\n        if (this.currentTime > this.nextTime) {\n            this.timeElapsed = this.currentTime - this.lastTime;\n            this.lastTime = this.currentTime;\n            this.nextTime = this.currentTime + this.frameTime;\n            return true;\n        } else return false;\n    }\n    getTimeElapsed() {\n        this.currentTime = new Date().getTime();\n        this.timeElapsed = this.currentTime - this.lastTime;\n        this.lastTime = this.currentTime;\n        return this.timeElapsed;\n    }\n}\nvar $6f7c4b99a861fe4c$export$2e2bcd8739ae039 = $6f7c4b99a861fe4c$var$Timer;\n\n\nclass $94f6e316629eca7d$var$Vector2d {\n    constructor(a, b){\n        this.x = a;\n        this.y = b;\n    }\n    add(vector) {\n        this.x += vector.x;\n        this.y += vector.y;\n        return this;\n    }\n    subtract(vector) {\n        this.x -= vector.x;\n        this.y -= vector.y;\n        return this;\n    }\n    multiply(multiplier) {\n        this.x *= multiplier;\n        this.y *= multiplier;\n        return this;\n    }\n    divide(divisor) {\n        this.x /= divisor;\n        this.y /= divisor;\n        return this;\n    }\n    // also called length of a 2d vector, \n    // hypotenuse of a right triangle\n    magnitude() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    normalize() {\n        return this.divide(this.magnitude());\n    }\n    static dot(vector1, vector2) {\n        return vector1.x * vector2.x + vector1.y * vector2.y;\n    }\n    static sign(vector1, vector2) {\n        if (vector1.y * vector2.x > vector1.x * vector2.y) return 1;\n        else return -1;\n    }\n}\nvar $94f6e316629eca7d$export$2e2bcd8739ae039 = $94f6e316629eca7d$var$Vector2d;\n\n\n\nclass $2bc85bb134c0aae0$export$42a9d1bcccbbcaf9 {\n    static sort(a, b) {\n        return a.dFitness - b.dFitness;\n    }\n    constructor(w = [], dFitness = 0){\n        this.vecWeights = [];\n        this.dFitness = 0;\n        if (w.length < 1) this.dFitness = 0;\n        else if (w.length > 0) {\n            this.vecWeights = w;\n            this.dFitness = dFitness;\n        }\n    }\n}\nclass $2bc85bb134c0aae0$var$GeneticAlgorithm {\n    constructor(popsize, MutRat, CrossRat, numweights){\n        this.vecPop = [];\n        this.iPopSize = popsize;\n        this.dMutationRate = MutRat;\n        this.dCrossoverRate = CrossRat;\n        this.iChromoLength = numweights;\n        this.dTotalFitness = 0;\n        this.cGeneration = 0;\n        this.iFittestGenome = 0;\n        this.dBestFitness = 0;\n        this.dWorstFitness = 99999999;\n        this.dAverageFitness = 0;\n        //initialise population with chromosomes consisting of random\n        //weights while all fitnesses are zero\n        for(let i = 0; i < this.iPopSize; i++){\n            this.vecPop.push(new $2bc85bb134c0aae0$export$42a9d1bcccbbcaf9([], 0));\n            for(let j = 0; j < this.iChromoLength; j++)this.vecPop[i].vecWeights.push(Math.random());\n        }\n    }\n    //---------------------------------mutate--------------------------------\n    //\n    //\tmutates a chromosome by perturbing its weights by an amount not \n    //\tgreater than dMaxPerturbation\n    //  this mutates the chromo in place\n    //-----------------------------------------------------------------------\n    mutate(chromo) {\n        // traverse the chromosome and mutate each weight dependent\n        // on the mutation rate\n        for(let i = 0; i < chromo.length; i++)// do we perturb this weight?\n        if (Math.random() < this.dMutationRate) // add or subtract a small value to the weight\n        // Math.random() - Math.random() returns a value between -1 and 1\n        chromo[i] += (Math.random() - Math.random()) * (0, $323e6d8c0c12152e$export$35572e150f3df791);\n    }\n    //----------------------------------getChromoRoulette()------------------\n    //\n    //\treturns a chromo based on roulette wheel sampling\n    //\n    //-----------------------------------------------------------------------\n    getChromoRoulette() {\n        //generate a random number between 0 & total fitness count\n        const slice = Math.random() * this.dTotalFitness;\n        //this will be set to the chosen chromosome\n        let theChosenOne;\n        //go through the chromosones adding up the fitness so far\n        let fitnessSoFar = 0;\n        for(let i = 0; i < this.iPopSize; i++){\n            fitnessSoFar += this.vecPop[i].dFitness;\n            //if the fitness so far > random number return the chromo at \n            //this point\n            if (fitnessSoFar >= slice) {\n                theChosenOne = this.vecPop[i];\n                break;\n            }\n        }\n        if (typeof theChosenOne === \"undefined\") throw new Error(\"not a genome!\");\n        return theChosenOne;\n    }\n    //-------------------------------------crossover()-----------------------\n    //\t\n    //  given parents and storage for the offspring this method performs\n    //\tcrossover according to the GAs crossover rate\n    //-----------------------------------------------------------------------\n    crossover(mum, dad, baby1, baby2) {\n        //just return parents as offspring dependent on the rate\n        //or if parents are the same\n        if (Math.random() > this.dCrossoverRate || mum === dad) {\n            baby1 = mum;\n            baby2 = dad;\n            return;\n        }\n        //determine a crossover point\n        let cp = Math.round(Math.random() * (this.iChromoLength - 1));\n        //create the offspring\n        for(let i = 0; i < cp; i++){\n            baby1.push(mum[i]);\n            baby2.push(dad[i]);\n        }\n        for(let i = cp; i < mum.length; i++){\n            baby1.push(dad[i]);\n            baby2.push(mum[i]);\n        }\n        return;\n    }\n    //-----------------------------------epoch()-----------------------------\n    //\n    //\ttakes a population of chromosones and runs the algorithm through one\n    //\t cycle.\n    //\tReturns a new population of chromosones.\n    //\n    //-----------------------------------------------------------------------\n    epoch(oldPop) {\n        //assign the given population to the classes population\n        this.vecPop = oldPop;\n        //reset the appropriate variables\n        this.reset();\n        //sort the population (for scaling and elitism)\n        this.vecPop.sort((a, b)=>a.dFitness - b.dFitness);\n        //calculate best, worst, average and total fitness\n        this.calculateBestWorstAvTot();\n        //create a temporary vector to store new chromosones\n        const vecNewPop = [];\n        //Now to add a little elitism we shall add in some copies of the\n        //fittest genomes. Make sure we add an EVEN number or the roulette\n        //wheel sampling will crash\n        if (!((0, $323e6d8c0c12152e$export$eaffa1d0ecbd528) * (0, $323e6d8c0c12152e$export$8e782db2810859d9) % 2)) this.grabNBest((0, $323e6d8c0c12152e$export$8e782db2810859d9), (0, $323e6d8c0c12152e$export$eaffa1d0ecbd528), vecNewPop);\n        //now we enter the GA loop\n        //repeat until a new population is generated\n        while(vecNewPop.length < this.iPopSize){\n            //grab two chromosones\n            const mum = this.getChromoRoulette();\n            const dad = this.getChromoRoulette();\n            //create some offspring via crossover\n            const baby1 = [];\n            const baby2 = [];\n            this.crossover(mum.vecWeights, dad.vecWeights, baby1, baby2);\n            //now we mutate\n            this.mutate(baby1);\n            this.mutate(baby2);\n            //now copy into vecNewPop population\n            vecNewPop.push(new $2bc85bb134c0aae0$export$42a9d1bcccbbcaf9(baby1, 0));\n            vecNewPop.push(new $2bc85bb134c0aae0$export$42a9d1bcccbbcaf9(baby2, 0));\n        }\n        //finished so assign new pop back into m_vecPop\n        this.vecPop = vecNewPop;\n        return this.vecPop;\n    }\n    //-------------------------grabNBest----------------------------------\n    //\n    //\tThis works like an advanced form of elitism by inserting NumCopies\n    //  copies of the NBest most fittest genomes into a population vector\n    //--------------------------------------------------------------------\n    grabNBest(nBest, numCopies, pop) {\n        let nB = nBest;\n        //add the required amount of copies of the n most fittest \n        //to the supplied vector\n        while(nB--)for(let i = 0; i < numCopies; i++)pop.push(this.vecPop[this.iPopSize - 1 - nB]);\n    }\n    //-----------------------calculateBestWorstAvTot-----------------------\t\n    //\n    //\tcalculates the fittest and weakest genome and the average/total \n    //\tfitness scores\n    //---------------------------------------------------------------------\n    calculateBestWorstAvTot() {\n        this.dTotalFitness = 0;\n        let highestSoFar = 0;\n        let lowestSoFar = 9999999;\n        for(let i = 0; i < this.iPopSize; i++){\n            //update fittest if necessary\n            if (this.vecPop[i].dFitness > highestSoFar) {\n                highestSoFar = this.vecPop[i].dFitness;\n                this.iFittestGenome = i;\n                this.dBestFitness = highestSoFar;\n            }\n            //update worst if necessary\n            if (this.vecPop[i].dFitness < lowestSoFar) {\n                lowestSoFar = this.vecPop[i].dFitness;\n                this.dWorstFitness = lowestSoFar;\n            }\n            this.dTotalFitness += this.vecPop[i].dFitness;\n        } //next chromo\n        this.dAverageFitness = this.dTotalFitness / this.iPopSize;\n    }\n    //-------------------------reset()------------------------------\n    //\n    //\tresets all the relevant variables ready for a new generation\n    //--------------------------------------------------------------\n    reset() {\n        this.dTotalFitness = 0;\n        this.dBestFitness = 0;\n        this.dWorstFitness = 9999999;\n        this.dAverageFitness = 0;\n    }\n    //accessor methods\n    getChromos() {\n        return this.vecPop;\n    }\n    getGeneration() {\n        return this.cGeneration;\n    }\n    averageFitness() {\n        return this.dTotalFitness / this.iPopSize;\n    }\n    bestFitness() {\n        return this.dBestFitness;\n    }\n}\nvar $2bc85bb134c0aae0$export$2e2bcd8739ae039 = $2bc85bb134c0aae0$var$GeneticAlgorithm;\n\n\n\nclass $730cc5316bb92ec7$var$Neuron {\n    constructor(numInputs){\n        this.vecWeight = [];\n        //we need an additional weight for the bias hence the +1\n        this.numInputs = numInputs;\n        for(let i = 0; i < numInputs + 1; ++i)this.vecWeight.push(Math.random());\n    }\n}\nvar $730cc5316bb92ec7$export$2e2bcd8739ae039 = $730cc5316bb92ec7$var$Neuron;\n\n\nclass $86a107e811c366ae$var$NeuronLayer {\n    constructor(numNeurons, numInputsPerNeuron){\n        //the layer of neurons\n        this.vecNeurons = [];\n        this.numNeurons = numNeurons;\n        this.numInputsPerNeuron = numInputsPerNeuron;\n        for(let i = 0; i < numNeurons; i++)this.vecNeurons.push(new (0, $730cc5316bb92ec7$export$2e2bcd8739ae039)(this.numInputsPerNeuron));\n    }\n}\nvar $86a107e811c366ae$export$2e2bcd8739ae039 = $86a107e811c366ae$var$NeuronLayer;\n\n\n\nclass $37b5892f7e409e2f$var$NeuralNet {\n    constructor(){\n        this.neuronLayers = [];\n        this.numInputs = (0, $323e6d8c0c12152e$export$5753e036582e2d24);\n        this.numOutputs = (0, $323e6d8c0c12152e$export$8c1c414cd78ab8b5);\n        this.numHiddenLayers = (0, $323e6d8c0c12152e$export$6fb51cf587721d5c);\n        this.neuronsPerHiddenLayer = (0, $323e6d8c0c12152e$export$c40ba6762188f6b0);\n    }\n    createNet() {\n        //create the layers of the network\n        if (this.numHiddenLayers > 0) {\n            //create first hidden layer\n            this.neuronLayers.push(new (0, $86a107e811c366ae$export$2e2bcd8739ae039)(this.neuronsPerHiddenLayer, this.numInputs));\n            for(let i = 0; i < this.numHiddenLayers; i++)this.neuronLayers.push(new (0, $86a107e811c366ae$export$2e2bcd8739ae039)(this.neuronsPerHiddenLayer, this.neuronsPerHiddenLayer));\n            //create output layer\n            this.neuronLayers.push(new (0, $86a107e811c366ae$export$2e2bcd8739ae039)(this.numOutputs, this.neuronsPerHiddenLayer));\n        } else //create output layer\n        this.neuronLayers.push(new (0, $86a107e811c366ae$export$2e2bcd8739ae039)(this.numOutputs, this.numInputs));\n    }\n    //\treturns the total number of weights needed for the net\n    getNumberOfWeights() {\n        let weights = 0;\n        //for each layer\n        for(let i = 0; i < this.numHiddenLayers; i++){\n            //for each neuron\n            for(let j = 0; j < this.neuronLayers[i].numNeurons; j++)//for each weight\n            for(let k = 0; k < this.neuronLayers[i].vecNeurons[j].numInputs; k++)weights++;\n        }\n        return weights;\n    }\n    //\treturns an array containing the weights\n    getWeights() {\n        //this will hold the weights\n        const weights = [];\n        //for each layer\n        for(let i = 0; i < this.numHiddenLayers; i++){\n            //for each neuron\n            for(let j = 0; j < this.neuronLayers[i].numNeurons; j++)//for each weight\n            for(let k = 0; k < this.neuronLayers[i].vecNeurons[j].numInputs; k++)weights.push(this.neuronLayers[i].vecNeurons[j].vecWeight[k]);\n        }\n        return weights;\n    }\n    putWeights(weights) {\n        let cWeight = 0;\n        //for each layer\n        for(let i = 0; i < this.numHiddenLayers; i++){\n            //for each neuron\n            for(let j = 0; j < this.neuronLayers[i].numNeurons; j++)//for each weight\n            for(let k = 0; k < this.neuronLayers[i].vecNeurons[j].numInputs; k++)this.neuronLayers[i].vecNeurons[j].vecWeight[k] = weights[cWeight++];\n        }\n        return;\n    }\n    update(inputs) {\n        // stores the resultant outputs from each layer\n        let outputs = [];\n        let cWeight = 0;\n        // first check that we have the correct amount of inputs\n        if (inputs.length !== this.numInputs) // just return an empty vector if incorrect.\n        return outputs;\n        // For each layer....\n        for(let i = 0; i < this.numHiddenLayers; i++){\n            if (i > 0) inputs = outputs;\n            outputs.length = 0;\n            cWeight = 0;\n            // for each neuron sum the (inputs * corresponding weights).\n            // Throw the total at our sigmoid function to get the output.\n            for(let j = 0; j < this.neuronLayers[i].numNeurons; j++){\n                let netinput = 0;\n                this.numInputs = this.neuronLayers[i].vecNeurons[j].numInputs;\n                for(let k = 0; k < this.numInputs; k++)// sum the weights x inputs\n                netinput += this.neuronLayers[i].vecNeurons[j].vecWeight[k] * inputs[cWeight++];\n                // add in the bias\n                netinput += this.neuronLayers[i].vecNeurons[j].vecWeight[this.numInputs - 1] * (0, $323e6d8c0c12152e$export$545fcf3a97e70662);\n                // we can store the outputs from each layer as we generate them.\n                // The combined activation is first filtered through the sigmoid\n                // function\n                outputs.push(this.sigmoid(netinput, (0, $323e6d8c0c12152e$export$8c1d8879bfbdaabd)));\n                cWeight = 0;\n            }\n        }\n        return outputs;\n    }\n    sigmoid(netinput, response) {\n        return 1 / (1 + Math.exp(-1 * netinput / response));\n    }\n}\nvar $37b5892f7e409e2f$export$2e2bcd8739ae039 = $37b5892f7e409e2f$var$NeuralNet;\n\n\n\nclass $8951c85a05b20536$var$Parameters {\n    static #_ = (()=>{\n        /* General parameters */ this.windowWidth = 400;\n    })();\n    static #_1 = (()=>{\n        this.windowHeight = 400;\n    })();\n    static #_2 = (()=>{\n        this.framesPerSecond = 60;\n    })();\n    static #_3 = (()=>{\n        /* Used for the neural network */ this.numInputs = 4;\n    })();\n    static #_4 = (()=>{\n        this.numHidden = 1;\n    })();\n    static #_5 = (()=>{\n        this.neuronsPerHiddenLayer = 6;\n    })();\n    static #_6 = (()=>{\n        this.numOutputs = 2;\n    })();\n    static #_7 = (()=>{\n        /* for tweeking the sigmoid function */ this.activationResponse = 1;\n    })();\n    static #_8 = (()=>{\n        /* Bias value */ this.bias = -1;\n    })();\n    static #_9 = (()=>{\n        /* limits how fast the sweepers can turn */ this.maxTurnRate = 0.3;\n    })();\n    static #_10 = (()=>{\n        this.maxSpeed = 2;\n    })();\n    static #_11 = (()=>{\n        /* for controlling the size */ this.sweeperScale = 5;\n    })();\n    static #_12 = (()=>{\n        /* controller parameters */ this.numMines = 40;\n    })();\n    static #_13 = (()=>{\n        this.numSweepers = 30;\n    })();\n    static #_14 = (()=>{\n        /* number of time steps we allow for each generation to live */ this.numTicks = 2000;\n    })();\n    static #_15 = (()=>{\n        /* scaling factor for mines */ this.mineScale = 2;\n    })();\n    static #_16 = (()=>{\n        /* Genetic Algorithim parameters */ this.crossoverRate = 0.7;\n    })();\n    static #_17 = (()=>{\n        this.mutationRate = 0.1;\n    })();\n    static #_18 = (()=>{\n        /* the maximum amount the ga may mutate each weight by */ this.maxPerturbation = 0.3;\n    })();\n    static #_19 = (()=>{\n        /* used for elitism */ this.numElite = 4;\n    })();\n    static #_20 = (()=>{\n        this.numCopiesElite = 1;\n    })();\n}\nvar $8951c85a05b20536$export$2e2bcd8739ae039 = $8951c85a05b20536$var$Parameters;\n\n\nclass $cafaca3b07c4a330$var$TwoDimensionalMatrix {\n    constructor(){\n        this._11 = 0;\n        this._12 = 0;\n        this._13 = 0;\n        this._21 = 0;\n        this._22 = 0;\n        this._23 = 0;\n        this._31 = 0;\n        this._32 = 0;\n        this._33 = 0;\n    }\n    consumeMatrix(mIn) {\n        this._11 = mIn._11;\n        this._12 = mIn._12;\n        this._13 = mIn._13;\n        this._21 = mIn._21;\n        this._22 = mIn._22;\n        this._23 = mIn._23;\n        this._31 = mIn._31;\n        this._32 = mIn._32;\n        this._33 = mIn._33;\n    }\n    TwoDimensionalMatrixMultiply(mIn) {\n        const mat_temp = new $cafaca3b07c4a330$var$TwoDimensionalMatrix();\n        mat_temp._11 = this._11 * mIn._11 + this._12 * mIn._21 + this._13 * mIn._31;\n        mat_temp._12 = this._11 * mIn._12 + this._12 * mIn._22 + this._13 * mIn._32;\n        mat_temp._13 = this._11 * mIn._13 + this._12 * mIn._23 + this._13 * mIn._33;\n        mat_temp._21 = this._21 * mIn._11 + this._22 * mIn._21 + this._23 * mIn._31;\n        mat_temp._22 = this._21 * mIn._12 + this._22 * mIn._22 + this._23 * mIn._32;\n        mat_temp._23 = this._21 * mIn._13 + this._22 * mIn._23 + this._23 * mIn._33;\n        mat_temp._31 = this._31 * mIn._11 + this._32 * mIn._21 + this._33 * mIn._31;\n        mat_temp._32 = this._31 * mIn._12 + this._32 * mIn._22 + this._33 * mIn._32;\n        mat_temp._33 = this._31 * mIn._13 + this._32 * mIn._23 + this._33 * mIn._33;\n        this.consumeMatrix(mat_temp);\n    }\n    createIdentity() {\n        let matrix = new $cafaca3b07c4a330$var$TwoDimensionalMatrix();\n        matrix._11 = 1;\n        matrix._22 = 1;\n        matrix._33 = 1;\n        matrix._12 = 0;\n        matrix._13 = 0;\n        matrix._21 = 0;\n        matrix._23 = 0;\n        matrix._31 = 0;\n        matrix._32 = 0;\n        return matrix;\n    }\n    translate(x, y) {\n        let matrix = this.createIdentity();\n        matrix._31 = x;\n        matrix._32 = y;\n        this.TwoDimensionalMatrixMultiply(matrix);\n    }\n    scale(xScale, yScale) {\n        let matrix = this.createIdentity();\n        matrix._11 = xScale;\n        matrix._22 = yScale;\n        this.TwoDimensionalMatrixMultiply(matrix);\n    }\n    rotate(angle) {\n        let matrix = this.createIdentity();\n        const sin = Math.sin(angle);\n        const cos = Math.cos(angle);\n        matrix._11 = cos;\n        matrix._12 = sin;\n        matrix._21 = -sin;\n        matrix._22 = cos;\n        this.TwoDimensionalMatrixMultiply(matrix);\n    }\n    transformPoints(points) {\n        for(let i = 0; i < points.length; i++){\n            let tempX = this._11 * points[i].x + this._21 * points[i].y + this._31;\n            let tempY = this._12 * points[i].x + this._22 * points[i].y + this._32;\n            points[i].x = tempX;\n            points[i].y = tempY;\n        }\n    }\n}\nvar $cafaca3b07c4a330$export$2e2bcd8739ae039 = $cafaca3b07c4a330$var$TwoDimensionalMatrix;\n\n\n//-------------------------------------Clamp()-----------------------------------------\n//\n//\tclamps the first argument between the second two\n//\n//-------------------------------------------------------------------------------------\nconst $e86236eac40c38ae$var$clamp = (num, min, max)=>Math.min(Math.max(num, min), max);\nvar $e86236eac40c38ae$export$2e2bcd8739ae039 = $e86236eac40c38ae$var$clamp;\n\n\nclass $dc902dc767253299$var$Minesweeper {\n    getNumberOfWeights() {\n        return this.brain.getNumberOfWeights();\n    }\n    constructor(){\n        this.brain = new (0, $37b5892f7e409e2f$export$2e2bcd8739ae039)();\n        this.position = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(Math.random() * (0, $8951c85a05b20536$export$2e2bcd8739ae039).windowWidth, Math.random() * (0, $8951c85a05b20536$export$2e2bcd8739ae039).windowHeight);\n        this.rotation = Math.random() * 2 * Math.PI;\n        this.lookAt = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(Math.sin(this.rotation) * -1, Math.cos(this.rotation));\n        this.velocity = 0;\n        this.minesFound = 0;\n        this.scale = (0, $8951c85a05b20536$export$2e2bcd8739ae039).sweeperScale;\n        this.closestMine = 0;\n        this.leftTrack = 0.16;\n        this.rightTrack = 0.16;\n    }\n    /*****\r\n     * reset\r\n     * Resets the sweepers position, fitness and rotation\r\n     * \r\n    */ reset() {\n        this.position = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(Math.random() * (0, $8951c85a05b20536$export$2e2bcd8739ae039).windowWidth, Math.random() * (0, $8951c85a05b20536$export$2e2bcd8739ae039).windowHeight);\n        this.rotation = Math.random() * 2 * Math.PI;\n        this.minesFound = 0;\n    }\n    /**\r\n     * worldTransform\r\n     * \r\n     * sets up a translation matrix for the sweeper according to its\r\n     *  scale, rotation and position. Returns the transformed vertices.\r\n     * \r\n     */ worldTransform(sweeper) {\n        const matTransform = new (0, $cafaca3b07c4a330$export$2e2bcd8739ae039)();\n        matTransform.scale(this.scale, this.scale);\n        matTransform.translate(this.position.x, this.position.y);\n        matTransform.rotate(this.rotation);\n        matTransform.transformPoints(sweeper);\n    }\n    /**\r\n     * update() \r\n     * First we take sensor readings and feed these into the sweepers brain.\r\n    * The inputs are:\r\n    * A vector to the closest mine (x, y)\r\n    * The sweepers 'look at' vector (x, y)\r\n    * We receive two outputs from the brain: leftTrack & rightTrack.\r\n    * Given a force for each track we calculate the resultant rotation \r\n    * and acceleration and apply to current velocity vector.\r\n    * */ update(mines) {\n        const inputs = [];\n        const closestMine = this.getClosestMine(mines);\n        closestMine.normalize();\n        inputs.push(closestMine.x);\n        inputs.push(closestMine.y);\n        inputs.push(this.lookAt.x);\n        inputs.push(this.lookAt.y);\n        const outputs = this.brain.update(inputs);\n        if (outputs.length !== (0, $8951c85a05b20536$export$2e2bcd8739ae039).numOutputs) throw new Error(\"Outputs length does not match number of outputs\");\n        this.leftTrack = outputs[0];\n        this.rightTrack = outputs[1];\n        let rotForce = this.leftTrack - this.rightTrack;\n        rotForce = (0, $e86236eac40c38ae$export$2e2bcd8739ae039)(rotForce, -(0, $8951c85a05b20536$export$2e2bcd8739ae039).maxTurnRate, (0, $8951c85a05b20536$export$2e2bcd8739ae039).maxTurnRate);\n        this.rotation += rotForce;\n        this.velocity = this.leftTrack + this.rightTrack;\n        this.lookAt.x = -Math.sin(this.rotation);\n        this.lookAt.y = Math.cos(this.rotation);\n        this.position.add(this.lookAt.multiply(this.velocity));\n        if (this.position.x < 0) this.position.x = (0, $8951c85a05b20536$export$2e2bcd8739ae039).windowWidth;\n        if (this.position.x > (0, $8951c85a05b20536$export$2e2bcd8739ae039).windowWidth) this.position.x = 0;\n        if (this.position.y < 0) this.position.y = (0, $8951c85a05b20536$export$2e2bcd8739ae039).windowHeight;\n        if (this.position.y > (0, $8951c85a05b20536$export$2e2bcd8739ae039).windowHeight) this.position.y = 0;\n        return true;\n    }\n    getClosestMine(mines) {\n        let closestMine = 0;\n        let closestDistance = Number.MAX_VALUE;\n        for(let i = 0; i < mines.length; i++){\n            const distance = this.position.subtract(mines[i]).magnitude();\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestMine = i;\n            }\n        }\n        return mines[closestMine];\n    }\n    incrementMinesFound() {\n        this.minesFound++;\n    }\n    getMinesFound() {\n        return this.minesFound;\n    }\n    getPosition() {\n        return this.position;\n    }\n    checkForMine(mines, size) {\n        const distance = this.position.subtract(mines[this.closestMine]).magnitude();\n        if (distance < size + 5) return this.closestMine;\n        return -1;\n    }\n    // accessors\n    incrementFitness() {\n        this.incrementMinesFound();\n    }\n    fitness() {\n        return this.minesFound;\n    }\n    putWeights(w) {\n        this.brain.putWeights(w);\n    }\n}\nvar $dc902dc767253299$export$2e2bcd8739ae039 = $dc902dc767253299$var$Minesweeper;\n\n\n\nconst $68677b18c84ba1fc$var$numberSweeperVertices = 16;\nconst $68677b18c84ba1fc$var$sweeper = new Array($68677b18c84ba1fc$var$numberSweeperVertices);\n$68677b18c84ba1fc$var$sweeper[0] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(-1, -1);\n$68677b18c84ba1fc$var$sweeper[1] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(-1, 1);\n$68677b18c84ba1fc$var$sweeper[2] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(-0.5, 1);\n$68677b18c84ba1fc$var$sweeper[3] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(-0.5, -1);\n$68677b18c84ba1fc$var$sweeper[4] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(0.5, -1);\n$68677b18c84ba1fc$var$sweeper[5] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(1, -1);\n$68677b18c84ba1fc$var$sweeper[6] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(1, 1);\n$68677b18c84ba1fc$var$sweeper[7] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(0.5, 1);\n$68677b18c84ba1fc$var$sweeper[8] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(-0.5, -0.5);\n$68677b18c84ba1fc$var$sweeper[9] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(0.5, -0.5);\n$68677b18c84ba1fc$var$sweeper[10] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(-0.5, 0.5);\n$68677b18c84ba1fc$var$sweeper[11] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(-0.25, 0.5);\n$68677b18c84ba1fc$var$sweeper[12] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(-0.25, 1.75);\n$68677b18c84ba1fc$var$sweeper[13] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(0.25, 1.75);\n$68677b18c84ba1fc$var$sweeper[14] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(0.25, 0.5);\n$68677b18c84ba1fc$var$sweeper[15] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(0.5, 0.5);\nconst $68677b18c84ba1fc$var$numberMineVertices = 4;\nconst $68677b18c84ba1fc$var$mine = new Array($68677b18c84ba1fc$var$numberMineVertices);\n$68677b18c84ba1fc$var$mine[0] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(-1, -1);\n$68677b18c84ba1fc$var$mine[1] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(-1, 1);\n$68677b18c84ba1fc$var$mine[2] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(1, 1);\n$68677b18c84ba1fc$var$mine[3] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(1, -1);\nclass $68677b18c84ba1fc$var$Controller {\n    constructor(){\n        // array of mines\n        this.vecMines = [];\n        // vertex buffer for the sweeper shape's vertices\n        this.sweeperVB = [];\n        // vertex buffer for the mine shape's vertices\n        this.mineVB = [];\n        this.fastRender = false;\n        this.iTick = 0;\n        this.iGeneration = 0;\n        // stores the average fitness per generation for use in graphing.\n        this.vecAvFitness = [];\n        // stores the best fitness per generation\n        this.vecBestFitness = [];\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = 800;\n        canvas.height = 600;\n        document.body.appendChild(canvas);\n        this.canvas = canvas;\n        this.numberOfSweepers = (0, $323e6d8c0c12152e$export$f3f24420e63561d6);\n        this.numberOfMines = (0, $323e6d8c0c12152e$export$f7f03d85ad8d41c5);\n        this.vecThePopulation = [];\n        this.vecSweepers = [];\n        for(let i = 0; i < (0, $323e6d8c0c12152e$export$f3f24420e63561d6); i++)this.vecSweepers.push(new (0, $dc902dc767253299$export$2e2bcd8739ae039)());\n        // get the total number of weights used in the sweepers\n        // neural network so we can initialise the GA\n        this.numberOfWeightsInNN = this.vecSweepers[0].getNumberOfWeights();\n        // initialise the Genetic Algorithm class\n        this.geneticAlgorithm = new (0, $2bc85bb134c0aae0$export$2e2bcd8739ae039)(this.numberOfSweepers, (0, $323e6d8c0c12152e$export$4a7f34cc4a79ff57), (0, $323e6d8c0c12152e$export$e5279d5a2c3f963c), this.numberOfWeightsInNN);\n        // Get the weights from the GA and insert into the sweepers brains\n        this.vecThePopulation = this.geneticAlgorithm.getChromos();\n        for(let i = 0; i < this.numberOfSweepers; i++)this.vecSweepers[i].putWeights(this.vecThePopulation[i].vecWeights);\n        // initialize mines in random positions within the application window\n        for(let i = 0; i < this.numberOfMines; i++)this.vecMines.push(new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(Math.random() * canvas.width, Math.random() * canvas.height));\n        // fill the vertex buffers\n        for(let i = 0; i < $68677b18c84ba1fc$var$sweeper.length; i++)this.sweeperVB.push($68677b18c84ba1fc$var$sweeper[i]);\n        for(let i = 0; i < $68677b18c84ba1fc$var$mine.length; i++)this.mineVB.push($68677b18c84ba1fc$var$mine[i]);\n    }\n    destroy() {}\n    render() {\n        const generationText = `Generation: ${this.iGeneration}`;\n        const ctx = this.canvas.getContext(\"2d\");\n        if (!ctx) return;\n        ctx.fillStyle = \"white\";\n        ctx.strokeRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.fill();\n        ctx.strokeStyle = \"black\";\n        ctx.lineWidth = 1;\n        ctx.font = \"16px arial\";\n        ctx.strokeText(generationText, 5, 5);\n        if (!this.fastRender) {\n            for(let i = 0; i < this.numberOfMines; i++){\n                ctx.beginPath();\n                ctx.strokeStyle = \"green\";\n                ctx.lineWidth = 1;\n                const mineVB = JSON.parse(JSON.stringify(this.mineVB));\n                this.worldTransform(mineVB, this.vecMines[i]);\n                ctx.moveTo(mineVB[0].x, mineVB[0].y);\n                for(let vert = 1; vert < mineVB.length; vert++)ctx.lineTo(mineVB[vert].x, mineVB[vert].y);\n                ctx.lineTo(mineVB[0].x, mineVB[0].y);\n                ctx.stroke();\n                ctx.closePath();\n            }\n            ctx.strokeStyle = \"red\";\n            for(let i = 0; i < this.numberOfSweepers; i++){\n                if (i === (0, $323e6d8c0c12152e$export$8e782db2810859d9)) ctx.strokeStyle = \"black\";\n                ctx.beginPath();\n                const sweeperVB = JSON.parse(JSON.stringify(this.sweeperVB));\n                this.worldTransform(sweeperVB, this.vecSweepers[i].getPosition());\n                ctx.moveTo(sweeperVB[0].x, sweeperVB[0].y);\n                for(let vert = 1; vert < sweeperVB.length; vert++)ctx.lineTo(sweeperVB[vert].x, sweeperVB[vert].y);\n                ctx.lineTo(sweeperVB[0].x, sweeperVB[0].y);\n                ctx.stroke();\n                ctx.closePath();\n            }\n        } else this.plotStats(ctx);\n    }\n    worldTransform(vBuffer, vPos) {\n        // create a transformation matrix\n        const matTransform = new (0, $cafaca3b07c4a330$export$2e2bcd8739ae039)();\n        // scale\n        matTransform.scale((0, $323e6d8c0c12152e$export$74957bad4521bafe), (0, $323e6d8c0c12152e$export$74957bad4521bafe));\n        // and translate\n        matTransform.translate(vPos.x, vPos.y);\n        // now transform the ships vertices\n        matTransform.transformPoints(vBuffer);\n    }\n    //-------------------------------------Update-----------------------------\n    //\n    //\tThis is the main workhorse. The entire simulation is controlled from here.\n    update() {\n        //run the sweepers through CParams::iNumTicks amount of cycles. During\n        //this loop each sweepers NN is constantly updated with the appropriate\n        //information from its surroundings. The output from the NN is obtained\n        //and the sweeper is moved. If it encounters a mine its fitness is\n        //updated appropriately,\n        if (this.iTick++ < (0, $323e6d8c0c12152e$export$281869dc3236940)) for(let i = 0; i < this.numberOfSweepers; i++){\n            if (!this.vecSweepers[i].update(this.vecMines)) {\n                // error\n                console.log(\"error in update, wrong amount of NN inputs\");\n                return false;\n            }\n            const grabHit = this.vecSweepers[i].checkForMine(this.vecMines, (0, $323e6d8c0c12152e$export$74957bad4521bafe));\n            if (grabHit >= 0) {\n                // we have discovered a mine so increase fitness\n                this.vecSweepers[i].incrementFitness();\n                // mine found so replace the mine with another at a random \n                // position\n                this.vecMines[grabHit] = new (0, $94f6e316629eca7d$export$2e2bcd8739ae039)(Math.random() * this.canvas.width, Math.random() * this.canvas.height);\n            }\n            this.vecThePopulation[i].dFitness = this.vecSweepers[i].fitness();\n        }\n        else {\n            // update the stats to be used in our stat window\n            this.vecAvFitness.push(this.geneticAlgorithm.averageFitness());\n            this.vecBestFitness.push(this.geneticAlgorithm.bestFitness());\n            this.iGeneration++;\n            // reset cycles\n            this.iTick = 0;\n            // run the GA to create a new population\n            this.vecThePopulation = this.geneticAlgorithm.epoch(this.vecThePopulation);\n            // insert the new (hopefully)improved brains back into the sweepers\n            // and reset their positions etc\n            for(let i = 0; i < this.numberOfSweepers; i++){\n                this.vecSweepers[i].putWeights(this.vecThePopulation[i].vecWeights);\n                this.vecSweepers[i].reset();\n            }\n        }\n        return true;\n    }\n    plotStats(ctx) {\n        if (!ctx) return;\n        const s = `Best Fitness: ${this.geneticAlgorithm.bestFitness()}`;\n        const s2 = `Average Fitness: ${this.geneticAlgorithm.averageFitness()}`;\n        ctx.font = \"16px arial\";\n        ctx.strokeText(s, 5, 5);\n        ctx.strokeText(s2, 5, 25);\n        ctx.strokeStyle = \"black\";\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(0, 200);\n        ctx.lineTo(200, 200);\n        ctx.stroke();\n        ctx.closePath();\n        ctx.strokeStyle = \"red\";\n        ctx.beginPath();\n        ctx.moveTo(0, 200);\n        for(let i = 0; i < this.vecAvFitness.length; i++)ctx.lineTo(i, 200 - this.vecAvFitness[i]);\n        ctx.stroke();\n        ctx.closePath();\n        ctx.strokeStyle = \"blue\";\n        ctx.beginPath();\n        ctx.moveTo(0, 200);\n        for(let i = 0; i < this.vecBestFitness.length; i++)ctx.lineTo(i, 200 - this.vecBestFitness[i]);\n        ctx.stroke();\n        ctx.closePath();\n    }\n    // accessor methods\n    getFastRender() {\n        return this.fastRender;\n    }\n    setFastRender(value) {\n        this.fastRender = value;\n    }\n    fastRenderToggler() {\n        this.fastRender = !this.fastRender;\n    }\n}\nvar $68677b18c84ba1fc$export$2e2bcd8739ae039 = $68677b18c84ba1fc$var$Controller;\n\n\n\nclass $76511dfb7d36bdfc$var$cppMessageSystem {\n    constructor(){}\n    static getInstance() {\n        if (!$76511dfb7d36bdfc$var$cppMessageSystem.instance) $76511dfb7d36bdfc$var$cppMessageSystem.instance = new $76511dfb7d36bdfc$var$cppMessageSystem();\n        return $76511dfb7d36bdfc$var$cppMessageSystem.instance;\n    }\n    static #_ = (()=>{\n        this.messageQueue = [];\n    })();\n    static pushMessage(message) {\n        $76511dfb7d36bdfc$var$cppMessageSystem.messageQueue.push(message);\n    }\n    static popMessage() {\n        if ($76511dfb7d36bdfc$var$cppMessageSystem.messageQueue.length > 0) $76511dfb7d36bdfc$var$cppMessageSystem.messageQueue.pop();\n        return \"\";\n    }\n    static peekMessage() {\n        if ($76511dfb7d36bdfc$var$cppMessageSystem.messageQueue.length > 0) return $76511dfb7d36bdfc$var$cppMessageSystem.messageQueue[$76511dfb7d36bdfc$var$cppMessageSystem.messageQueue.length - 1];\n        return \"\";\n    }\n}\nclass $76511dfb7d36bdfc$export$861edd1ccea2f746 {\n    static getInstance() {\n        if (!$76511dfb7d36bdfc$export$861edd1ccea2f746.instance) $76511dfb7d36bdfc$export$861edd1ccea2f746.instance = new $76511dfb7d36bdfc$export$861edd1ccea2f746();\n        return $76511dfb7d36bdfc$export$861edd1ccea2f746.instance;\n    }\n    // emulate C++'s message system because it's definitely differnt from JS so why not\n    static messageProcesser() {\n        switch($76511dfb7d36bdfc$var$cppMessageSystem.popMessage()){\n            case \"start\":\n                $76511dfb7d36bdfc$export$861edd1ccea2f746.getInstance().controller = new (0, $68677b18c84ba1fc$export$2e2bcd8739ae039)();\n                break;\n            case \"paint\":\n                $76511dfb7d36bdfc$export$861edd1ccea2f746.getInstance().controller.render();\n                break;\n            case \"quit\":\n                $76511dfb7d36bdfc$export$861edd1ccea2f746.getInstance().done = true;\n                break;\n            default:\n                break;\n        }\n    }\n    constructor(){\n        this.controller = new (0, $68677b18c84ba1fc$export$2e2bcd8739ae039)();\n        this.done = false;\n        const timer = new (0, $6f7c4b99a861fe4c$export$2e2bcd8739ae039)((0, $323e6d8c0c12152e$export$5162177fdef0d83e));\n        timer.start();\n        while(!this.done){\n            while($76511dfb7d36bdfc$var$cppMessageSystem.peekMessage() !== \"\")$76511dfb7d36bdfc$export$861edd1ccea2f746.messageProcesser();\n            if (timer.readyForNextFrame()) {\n                if (!this.controller.update()) {\n                    console.error(\"Error in controller update\");\n                    this.done = true;\n                }\n                $76511dfb7d36bdfc$var$cppMessageSystem.pushMessage(\"paint\");\n            }\n        }\n    }\n}\nvar $76511dfb7d36bdfc$export$2e2bcd8739ae039 = $76511dfb7d36bdfc$export$861edd1ccea2f746;\n\n\nconst $6897a44075826865$var$app = (0, $76511dfb7d36bdfc$export$2e2bcd8739ae039).getInstance();\n\n})();\n//# sourceMappingURL=index.js.map\n","import Main from \"./classes/main\";\r\nconst app = Main.getInstance(); ","import Timer from \"./timer\";\r\nimport Controller from \"./controller\";\r\nimport { iFramesPerSecond } from \"../config\";\r\n\r\nclass cppMessageSystem {\r\n    private static instance: cppMessageSystem;\r\n    private constructor() { }\r\n    public static getInstance(): cppMessageSystem {\r\n        if (!cppMessageSystem.instance) {\r\n            cppMessageSystem.instance = new cppMessageSystem();\r\n        }\r\n        return cppMessageSystem.instance;\r\n    }\r\n    private static messageQueue: string[] = [];\r\n    public static pushMessage(message: string): void {\r\n        cppMessageSystem.messageQueue.push(message);\r\n    }\r\n    public static popMessage(): string {\r\n        if(cppMessageSystem.messageQueue.length>0) cppMessageSystem.messageQueue.pop();\r\n        return \"\";\r\n    }\r\n    public static peekMessage(): string {\r\n        if(cppMessageSystem.messageQueue.length>0) return cppMessageSystem.messageQueue[cppMessageSystem.messageQueue.length-1];\r\n        return \"\";\r\n    }\r\n    \r\n}\r\n// window.requestAnimationFrame(step);\r\n\r\nexport class Main {\r\n    private controller: Controller = new Controller();\r\n    private done: boolean = false;\r\n    \r\n    private static instance: Main;\r\n    static getInstance(): Main {\r\n        if (!Main.instance) {\r\n            Main.instance = new Main();\r\n        }\r\n        return Main.instance;\r\n    }\r\n    \r\n    // emulate C++'s message system because it's definitely differnt from JS so why not\r\n    public static messageProcesser(): void {\r\n        switch (cppMessageSystem.popMessage()) {\r\n            case \"start\":\r\n                Main.getInstance().controller = new Controller();   \r\n                break;\r\n            case \"paint\":\r\n                Main.getInstance().controller.render();\r\n                break;\r\n            case \"quit\":\r\n                Main.getInstance().done = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    constructor(){\r\n        const timer = new Timer(iFramesPerSecond);\r\n        timer.start();\r\n        while(!this.done){\r\n            while(cppMessageSystem.peekMessage() !== \"\"){ \r\n                Main.messageProcesser();\r\n            }\r\n            if(timer.readyForNextFrame()){\r\n               if(!this.controller.update()){\r\n                    console.error('Error in controller update');\r\n                    this.done = true;\r\n               }\r\n               cppMessageSystem.pushMessage(\"paint\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default Main;","import {iFramesPerSecond} from \"../config\";\r\n\r\nclass Timer {\r\n    private currentTime: number;\r\n    private lastTime: number;\r\n    private nextTime: number;\r\n    private frameTime: number;\r\n    private perfCountFreq: number;\r\n    private timeElapsed: number;\r\n    private fps: number;\r\n    constructor(fps: number = iFramesPerSecond){\r\n        this.currentTime = 0;\r\n        this.lastTime = 0;\r\n        this.nextTime = 0;\r\n        this.frameTime = 0;\r\n        // this strategy is mostly a byproduct of being a port from C++\r\n        this.perfCountFreq = 1000; //ms in a second \r\n        this.timeElapsed = 0;\r\n        this.fps = 0;\r\n        if(fps){\r\n            this.fps = fps;\r\n            this.frameTime = this.perfCountFreq / this.fps;\r\n            this.lastTime = new Date().getTime();\r\n            this.currentTime = this.lastTime;\r\n            this.nextTime = this.currentTime + this.frameTime;\r\n\r\n        }\r\n    }\r\n\r\n    public start(){\r\n        this.nextTime = new Date().getTime() + this.frameTime;\r\n    };\r\n\r\n    public readyForNextFrame(): boolean {\r\n        this.currentTime = new Date().getTime();\r\n        if(this.currentTime > this.nextTime){\r\n            this.timeElapsed = this.currentTime - this.lastTime;\r\n            this.lastTime = this.currentTime;\r\n            this.nextTime = this.currentTime + this.frameTime;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public getTimeElapsed(): number {\r\n        this.currentTime = new Date().getTime();\r\n        this.timeElapsed = this.currentTime - this.lastTime;\r\n        this.lastTime = this.currentTime;\r\n        return this.timeElapsed;\r\n    }\r\n\r\n}\r\n\r\nexport default Timer;","export const iFramesPerSecond  = 60;\r\nexport const iNumInputs = 4;\r\nexport const iNumHidden = 1;\r\nexport const iNeuronsPerHiddenLayer = 6;\r\nexport const iNumOutputs = 2;\r\nexport const dActivationResponse = 1;\r\nexport const dBias = -1;\r\nexport const dMaxTurnRate = 0.3;\r\nexport const dMaxSpeed = 2;\r\nexport const iSweeperScale = 5;\r\nexport const iNumMines = 40;\r\nexport const iNumSweepers = 30;\r\nexport const iNumTicks = 2000;\r\nexport const dMineScale = 2;\r\nexport const dCrossoverRate = 0.7;\r\nexport const dMutationRate = 0.1;\r\nexport const dMaxPerturbation = 0.3;\r\nexport const iNumElite = 4;\r\nexport const iNumCopiesElite = 1;\r\n","import Vector2d from \"./vector2d\";\r\nimport GeneticAlgorithm, { Genome } from \"./geneticAlgorithm\";\r\nimport { iNumElite, iNumMines, iNumTicks, iNumSweepers, dMutationRate, dCrossoverRate, dMineScale } from \"../config\";\r\nimport Minesweeper from \"./mineSweeper\";\r\nimport TwoDimensionalMatrix from \"./twoDimensionalMatrix\";\r\n\r\n\r\nconst numberSweeperVertices = 16;\r\nconst sweeper: Vector2d[] = new Array(numberSweeperVertices);\r\nsweeper[0] = new Vector2d(-1, -1);\r\nsweeper[1] = new Vector2d(-1, 1);\r\nsweeper[2] = new Vector2d(-0.5, 1);\r\nsweeper[3] = new Vector2d(-0.5, -1);\r\nsweeper[4] = new Vector2d(0.5, -1);\r\nsweeper[5] = new Vector2d(1, -1);\r\nsweeper[6] = new Vector2d(1, 1);\r\nsweeper[7] = new Vector2d(0.5, 1);\r\nsweeper[8] = new Vector2d(-0.5, -0.5);\r\nsweeper[9] = new Vector2d(0.5,-0.5);\r\nsweeper[10] = new Vector2d(-0.5, 0.5);\r\nsweeper[11] = new Vector2d(-.25,0.5);   \r\nsweeper[12] = new Vector2d(-0.25, 1.75);\r\nsweeper[13] = new Vector2d(0.25, 1.75);\r\nsweeper[14] = new Vector2d(0.25, 0.5);\r\nsweeper[15] = new Vector2d(0.5, 0.5);\r\n\r\nconst numberMineVertices = 4;\r\nconst mine: Vector2d[] = new Array(numberMineVertices); \r\nmine[0] = new Vector2d(-1, -1);\r\nmine[1] = new Vector2d(-1, 1);\r\nmine[2] = new Vector2d(1, 1);\r\nmine[3] = new Vector2d(1, -1);\r\n\r\n\r\n\r\nclass Controller {\r\n    // storage for the population of genomes\r\n    vecThePopulation: Genome[];\r\n    // array of sweepers\r\n    vecSweepers: Minesweeper[];\r\n    // array of mines\r\n    vecMines: Vector2d[] = [];\r\n    // size of population\r\n    numberOfSweepers: number;\r\n    // amount of mines in the world\r\n    numberOfMines: number;\r\n    // amount of weights in neural net\r\n    numberOfWeightsInNN: number;\r\n\r\n    // pointer to the GA class\r\n    private geneticAlgorithm: GeneticAlgorithm;\r\n\r\n    // vertex buffer for the sweeper shape's vertices\r\n    private sweeperVB: Vector2d[] = [];\r\n    // vertex buffer for the mine shape's vertices\r\n    private mineVB: Vector2d[] = [];\r\n\r\n    private fastRender: boolean = false;\r\n\r\n    private iTick: number = 0;\r\n\r\n    private iGeneration: number = 0;\r\n\r\n    // stores the average fitness per generation for use in graphing.\r\n    private vecAvFitness: number[] = [];\r\n    // stores the best fitness per generation\r\n    private vecBestFitness: number[] = [];\r\n\r\n    private canvas: HTMLCanvasElement;\r\n    constructor(){\r\n        const canvas = document.createElement(\"canvas\");\r\n        canvas.width = 800;\r\n        canvas.height = 600;\r\n        document.body.appendChild(canvas);\r\n        this.canvas = canvas;\r\n        this.numberOfSweepers = iNumSweepers;\r\n        this.numberOfMines = iNumMines;\r\n        this.vecThePopulation = [];\r\n        this.vecSweepers = [];\r\n        for(let i=0; i<iNumSweepers; i++){\r\n            this.vecSweepers.push(new Minesweeper());\r\n        }\r\n        // get the total number of weights used in the sweepers\r\n        // neural network so we can initialise the GA\r\n        this.numberOfWeightsInNN = this.vecSweepers[0].getNumberOfWeights();\r\n\r\n        // initialise the Genetic Algorithm class\r\n        this.geneticAlgorithm = new GeneticAlgorithm(\r\n            this.numberOfSweepers,\r\n            dMutationRate,\r\n            dCrossoverRate,\r\n            this.numberOfWeightsInNN);\r\n\r\n        // Get the weights from the GA and insert into the sweepers brains\r\n        this.vecThePopulation = this.geneticAlgorithm.getChromos();\r\n        for (let i=0; i<this.numberOfSweepers; i++) {\r\n            this.vecSweepers[i].putWeights(this.vecThePopulation[i].vecWeights);\r\n        }\r\n        // initialize mines in random positions within the application window\r\n        for (let i=0; i<this.numberOfMines; i++) {\r\n            this.vecMines.push(new Vector2d(Math.random() * canvas.width, Math.random() * canvas.height));\r\n        }\r\n       \r\n        // fill the vertex buffers\r\n        for (let i=0; i<sweeper.length; i++) {\r\n            this.sweeperVB.push(sweeper[i]);\r\n        }\r\n        for (let i=0; i<mine.length; i++) {\r\n            this.mineVB.push(mine[i]);\r\n        }   \r\n\r\n    }\r\n\r\n    destroy(){}\r\n\r\n    render():void{\r\n        const generationText = `Generation: ${this.iGeneration}`;\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        if(!ctx) return;\r\n        ctx.fillStyle = \"white\";\r\n        ctx.strokeRect(0, 0, this.canvas.width, this.canvas.height);\r\n        ctx.fill();\r\n        ctx.strokeStyle = \"black\";\r\n        ctx.lineWidth = 1;\r\n        ctx.font = \"16px arial\";\r\n        ctx.strokeText(generationText, 5, 5);\r\n        if(!this.fastRender){\r\n            for (let i=0; i<this.numberOfMines; i++) {\r\n                ctx.beginPath();\r\n                    ctx.strokeStyle = \"green\";\r\n                    ctx.lineWidth = 1;\r\n                const mineVB = JSON.parse(JSON.stringify(this.mineVB));\r\n                this.worldTransform(mineVB, this.vecMines[i]);\r\n                ctx.moveTo(mineVB[0].x, mineVB[0].y);\r\n                for (let vert=1; vert<mineVB.length; vert++) {\r\n                    ctx.lineTo(mineVB[vert].x, mineVB[vert].y);\r\n                }\r\n                ctx.lineTo(mineVB[0].x, mineVB[0].y);\r\n                ctx.stroke();\r\n                ctx.closePath();\r\n            }\r\n            ctx.strokeStyle = \"red\"\r\n            for (let i=0; i<this.numberOfSweepers; i++) {\r\n                if(i===iNumElite){\r\n                    ctx.strokeStyle = \"black\";\r\n                }\r\n                ctx.beginPath();\r\n                const sweeperVB = JSON.parse(JSON.stringify(this.sweeperVB));\r\n                this.worldTransform(sweeperVB, this.vecSweepers[i].getPosition());\r\n                ctx.moveTo(sweeperVB[0].x, sweeperVB[0].y);\r\n                for (let vert=1; vert<sweeperVB.length; vert++) {\r\n                    ctx.lineTo(sweeperVB[vert].x, sweeperVB[vert].y);\r\n                }\r\n                ctx.lineTo(sweeperVB[0].x, sweeperVB[0].y);\r\n                ctx.stroke();\r\n                ctx.closePath();\r\n            }\r\n        } else {\r\n            this.plotStats(ctx);\r\n        }\r\n    }\r\n\r\n    worldTransform(vBuffer:Vector2d[], vPos: Vector2d):void{\r\n        // create a transformation matrix\r\n        const matTransform = new TwoDimensionalMatrix();\r\n        // scale\r\n        matTransform.scale(dMineScale, dMineScale);\r\n        // and translate\r\n        matTransform.translate(vPos.x, vPos.y);\r\n        // now transform the ships vertices\r\n        matTransform.transformPoints(vBuffer);\r\n    }\r\n\r\n    //-------------------------------------Update-----------------------------\r\n    //\r\n    //\tThis is the main workhorse. The entire simulation is controlled from here.\r\n\r\n    update():boolean{\r\n        //run the sweepers through CParams::iNumTicks amount of cycles. During\r\n        //this loop each sweepers NN is constantly updated with the appropriate\r\n        //information from its surroundings. The output from the NN is obtained\r\n        //and the sweeper is moved. If it encounters a mine its fitness is\r\n        //updated appropriately,\r\n        if(this.iTick++ < iNumTicks) {\r\n            for (let i=0; i<this.numberOfSweepers; i++) {\r\n                if(!this.vecSweepers[i].update(this.vecMines)){\r\n                    // error\r\n                    console.log(\"error in update, wrong amount of NN inputs\");\r\n                    return false;\r\n                }\r\n                const grabHit = this.vecSweepers[i].checkForMine(this.vecMines, dMineScale);\r\n                if (grabHit >= 0) {\r\n                    // we have discovered a mine so increase fitness\r\n                    this.vecSweepers[i].incrementFitness();\r\n                    // mine found so replace the mine with another at a random \r\n                    // position\r\n                    this.vecMines[grabHit] = new Vector2d(Math.random() * this.canvas.width, Math.random() * this.canvas.height);\r\n                    \r\n                }\r\n                this.vecThePopulation[i].dFitness = this.vecSweepers[i].fitness();\r\n            }\r\n        }\r\n        // another generation is completed\r\n\r\n        // run the GA and update sweepers with their new NNs\r\n        else {\r\n            // update the stats to be used in our stat window\r\n            this.vecAvFitness.push(this.geneticAlgorithm.averageFitness());\r\n            this.vecBestFitness.push(this.geneticAlgorithm.bestFitness());\r\n            this.iGeneration++;\r\n            // reset cycles\r\n            this.iTick = 0;\r\n            // run the GA to create a new population\r\n            this.vecThePopulation = this.geneticAlgorithm.epoch(this.vecThePopulation);\r\n            // insert the new (hopefully)improved brains back into the sweepers\r\n            // and reset their positions etc\r\n            for (let i=0; i<this.numberOfSweepers; i++) {\r\n                this.vecSweepers[i].putWeights(this.vecThePopulation[i].vecWeights);\r\n                this.vecSweepers[i].reset();\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    plotStats(ctx: CanvasRenderingContext2D | null):void{\r\n        if(!ctx) return;\r\n        const s = `Best Fitness: ${this.geneticAlgorithm.bestFitness()}`;\r\n        const s2 = `Average Fitness: ${this.geneticAlgorithm.averageFitness()}`;\r\n        ctx.font = \"16px arial\";\r\n        ctx.strokeText(s, 5, 5);\r\n        ctx.strokeText(s2, 5, 25);\r\n        ctx.strokeStyle = \"black\";\r\n        ctx.lineWidth = 1;\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, 0);\r\n        ctx.lineTo(0, 200);\r\n        ctx.lineTo(200, 200);\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n        ctx.strokeStyle = \"red\";\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, 200);\r\n        for(let i=0; i<this.vecAvFitness.length; i++){\r\n            ctx.lineTo(i, 200 - this.vecAvFitness[i]);\r\n        }\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n        ctx.strokeStyle = \"blue\";\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, 200);\r\n        for(let i=0; i<this.vecBestFitness.length; i++){\r\n            ctx.lineTo(i, 200 - this.vecBestFitness[i]);\r\n        }\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n    }\r\n    // accessor methods\r\n    getFastRender(){return this.fastRender}\r\n    setFastRender(value:boolean){this.fastRender = value}\r\n    fastRenderToggler(){this.fastRender = !this.fastRender} \r\n};\r\nexport default Controller;\r\n","class Vector2d {\r\n  public x: number;\r\n  public y: number;\r\n  constructor(a:number,b:number){\r\n    this.x = a;\r\n    this.y = b;\r\n  }\r\n  add(vector:Vector2d){\r\n    this.x += vector.x;\r\n    this.y += vector.y;\r\n    return this;\r\n  }\r\n  subtract(vector:Vector2d){\r\n    this.x -= vector.x;\r\n    this.y -= vector.y;\r\n    return this;\r\n  }\r\n  multiply(multiplier:number){\r\n    this.x *= multiplier;\r\n    this.y *= multiplier;\r\n    return this;\r\n  }\r\n  divide(divisor:number){\r\n    this.x /= divisor;\r\n    this.y /= divisor;\r\n    return this;\r\n  }\r\n  // also called length of a 2d vector, \r\n  // hypotenuse of a right triangle\r\n  magnitude(){\r\n    return Math.sqrt(this.x*this.x + this.y*this.y);\r\n  }\r\n  normalize(){\r\n    return this.divide(this.magnitude());\r\n  }\r\n  static dot(vector1:Vector2d,vector2:Vector2d){\r\n    return vector1.x*vector2.x + vector1.y*vector2.y;\r\n  }\r\n  static sign(vector1:Vector2d,vector2:Vector2d){\r\n    if(vector1.y*vector2.x > vector1.x*vector2.y){\r\n      return 1;\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n\r\n};\r\n\r\nexport default Vector2d;\r\n","import { dMaxPerturbation, iNumCopiesElite, iNumElite } from \"../config\";\r\n\r\nexport class Genome {\r\n  vecWeights: number[] = [];\r\n  dFitness: number = 0;\r\n  static sort(a:Genome,b:Genome){\r\n    return a.dFitness - b.dFitness;\r\n  }\r\n  constructor(w:number[] = [], dFitness:number = 0) {\r\n    if(w.length < 1){\r\n      this.dFitness = 0;\r\n    } else if (w.length > 0){\r\n      this.vecWeights = w;\r\n      this.dFitness = dFitness;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nclass GeneticAlgorithm {\r\n  private iPopSize: number;\r\n  private dMutationRate: number;\r\n  private dCrossoverRate: number;\r\n  private iChromoLength: number;\r\n  private dTotalFitness: number;\r\n  private cGeneration: number;\r\n  private iFittestGenome: number;\r\n  private dBestFitness: number;\r\n  private dWorstFitness: number;\r\n  private dAverageFitness: number;\r\n  private vecPop: Genome[] = [];\r\n\r\n  constructor(popsize: number, MutRat: number, CrossRat: number, numweights: number){\r\n    this.iPopSize = popsize;\r\n    this.dMutationRate = MutRat;\r\n    this.dCrossoverRate = CrossRat;\r\n    this.iChromoLength = numweights;\r\n    this.dTotalFitness = 0;\r\n    this.cGeneration = 0;\r\n    this.iFittestGenome = 0;\r\n    this.dBestFitness = 0;\r\n    this.dWorstFitness = 99999999;\r\n    this.dAverageFitness = 0;\r\n    //initialise population with chromosomes consisting of random\r\n\t  //weights while all fitnesses are zero\r\n    for (let i=0; i<this.iPopSize; i++) {\r\n      this.vecPop.push(new Genome([],0));\r\n      for (let j=0; j<this.iChromoLength; j++){\r\n        this.vecPop[i].vecWeights.push(Math.random());\r\n      }\r\n    }\r\n  }\r\n\r\n  //---------------------------------mutate--------------------------------\r\n  //\r\n  //\tmutates a chromosome by perturbing its weights by an amount not \r\n  //\tgreater than dMaxPerturbation\r\n  //  this mutates the chromo in place\r\n  //-----------------------------------------------------------------------\r\n  mutate(chromo: number[]) {\r\n    // traverse the chromosome and mutate each weight dependent\r\n    // on the mutation rate\r\n    for (let i=0; i<chromo.length; i++) {\r\n      // do we perturb this weight?\r\n      if (Math.random() < this.dMutationRate){\r\n        // add or subtract a small value to the weight\r\n        // Math.random() - Math.random() returns a value between -1 and 1\r\n        chromo[i] += ((Math.random() - Math.random()) * dMaxPerturbation);\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  //----------------------------------getChromoRoulette()------------------\r\n  //\r\n  //\treturns a chromo based on roulette wheel sampling\r\n  //\r\n  //-----------------------------------------------------------------------\r\n  getChromoRoulette():Genome {\r\n    //generate a random number between 0 & total fitness count\r\n    const slice = Math.random() * this.dTotalFitness;\r\n\r\n    //this will be set to the chosen chromosome\r\n    let theChosenOne;\r\n    \r\n    //go through the chromosones adding up the fitness so far\r\n    let fitnessSoFar = 0;\r\n    \r\n    for (let i=0; i<this.iPopSize; i++){\r\n      fitnessSoFar += this.vecPop[i].dFitness;\r\n      \r\n      //if the fitness so far > random number return the chromo at \r\n      //this point\r\n      if (fitnessSoFar >= slice){\r\n        theChosenOne = this.vecPop[i];\r\n        break;\r\n      }\r\n    }\r\n    if(typeof theChosenOne === \"undefined\") throw new Error('not a genome!');\r\n    return theChosenOne;\r\n  }\r\n\r\n  //-------------------------------------crossover()-----------------------\r\n  //\t\r\n  //  given parents and storage for the offspring this method performs\r\n  //\tcrossover according to the GAs crossover rate\r\n  //-----------------------------------------------------------------------\r\n  crossover(mum:number[], dad:number[], baby1:number[], baby2:number[]){\r\n    //just return parents as offspring dependent on the rate\r\n    //or if parents are the same\r\n    if ( (Math.random() > this.dCrossoverRate) || (mum === dad)) {\r\n      baby1 = mum;\r\n      baby2 = dad;\r\n      return;\r\n    }\r\n\r\n    //determine a crossover point\r\n    let cp = Math.round(Math.random() * (this.iChromoLength - 1));\r\n    //create the offspring\r\n    for (let i=0; i<cp; i++){\r\n      baby1.push(mum[i]);\r\n      baby2.push(dad[i]);\r\n    }\r\n\r\n    for (let i=cp; i<mum.length; i++){\r\n      baby1.push(dad[i]);\r\n      baby2.push(mum[i]);\r\n    }\r\n    return;\r\n  }\r\n\r\n\r\n\r\n  //-----------------------------------epoch()-----------------------------\r\n  //\r\n  //\ttakes a population of chromosones and runs the algorithm through one\r\n  //\t cycle.\r\n  //\tReturns a new population of chromosones.\r\n  //\r\n  //-----------------------------------------------------------------------\r\n  epoch(oldPop:Genome[]):Genome[]{\r\n    //assign the given population to the classes population\r\n    this.vecPop = oldPop;\r\n\r\n    //reset the appropriate variables\r\n    this.reset();\r\n\r\n    //sort the population (for scaling and elitism)\r\n    this.vecPop.sort((a,b)=>a.dFitness - b.dFitness);\r\n    //calculate best, worst, average and total fitness\r\n    this.calculateBestWorstAvTot();\r\n    \r\n    //create a temporary vector to store new chromosones\r\n    const vecNewPop:Genome[] = [];\r\n\r\n    //Now to add a little elitism we shall add in some copies of the\r\n    //fittest genomes. Make sure we add an EVEN number or the roulette\r\n    //wheel sampling will crash\r\n    if (!(iNumCopiesElite * iNumElite % 2)){\r\n      this.grabNBest(iNumElite, iNumCopiesElite, vecNewPop);\r\n    }\r\n    \r\n    //now we enter the GA loop\r\n    \r\n    //repeat until a new population is generated\r\n    while (vecNewPop.length < this.iPopSize){\r\n      //grab two chromosones\r\n      const mum = this.getChromoRoulette();\r\n      const dad = this.getChromoRoulette();\r\n\r\n      //create some offspring via crossover\r\n      const baby1:number[] = [];\r\n      const baby2:number[] = [];\r\n\r\n\r\n      this.crossover(mum.vecWeights, dad.vecWeights, baby1, baby2);\r\n\r\n      //now we mutate\r\n      this.mutate(baby1);\r\n      this.mutate(baby2);\r\n\r\n      //now copy into vecNewPop population\r\n      vecNewPop.push(new Genome(baby1, 0));\r\n      vecNewPop.push(new Genome(baby2, 0));\r\n    }\r\n\r\n    //finished so assign new pop back into m_vecPop\r\n    this.vecPop = vecNewPop;\r\n\r\n    return this.vecPop;\r\n  }\r\n\r\n  \r\n  //-------------------------grabNBest----------------------------------\r\n  //\r\n  //\tThis works like an advanced form of elitism by inserting NumCopies\r\n  //  copies of the NBest most fittest genomes into a population vector\r\n  //--------------------------------------------------------------------\r\n\r\n  grabNBest(nBest:number, numCopies:number,pop:Genome[]){\r\n    let nB = nBest;\r\n    //add the required amount of copies of the n most fittest \r\n    //to the supplied vector\r\n    while(nB--)\r\n    {\r\n      for (let i=0; i<numCopies; i++){\r\n        pop.push(this.vecPop[(this.iPopSize - 1) - nB]);\r\n      }\r\n    }\r\n  }\r\n  \r\n  //-----------------------calculateBestWorstAvTot-----------------------\t\r\n  //\r\n  //\tcalculates the fittest and weakest genome and the average/total \r\n  //\tfitness scores\r\n  //---------------------------------------------------------------------\r\n  calculateBestWorstAvTot(){\r\n    this.dTotalFitness = 0;\r\n    let highestSoFar = 0;\r\n    let lowestSoFar  = 9999999;\r\n    for (let i=0; i<this.iPopSize; i++){\r\n      //update fittest if necessary\r\n      if (this.vecPop[i].dFitness > highestSoFar){\r\n        highestSoFar = this.vecPop[i].dFitness;\r\n        this.iFittestGenome = i;\r\n        this.dBestFitness\t = highestSoFar;\r\n      }\r\n      //update worst if necessary\r\n      if (this.vecPop[i].dFitness < lowestSoFar){\r\n        lowestSoFar = this.vecPop[i].dFitness;\r\n        this.dWorstFitness = lowestSoFar;\r\n      }\r\n      this.dTotalFitness\t+= this.vecPop[i].dFitness;\r\n    }//next chromo\r\n    this.dAverageFitness = this.dTotalFitness / this.iPopSize;\r\n  }\r\n\r\n  //-------------------------reset()------------------------------\r\n  //\r\n  //\tresets all the relevant variables ready for a new generation\r\n  //--------------------------------------------------------------\r\n  reset() {\r\n    this.dTotalFitness = 0;\r\n    this.dBestFitness = 0;\r\n    this.dWorstFitness = 9999999;\r\n    this.dAverageFitness = 0;\r\n  }\r\n\r\n  //accessor methods\r\n  getChromos() {return this.vecPop;}\r\n  getGeneration() {return this.cGeneration;}\r\n  averageFitness() {return this.dTotalFitness / this.iPopSize;}\r\n  bestFitness() {return this.dBestFitness;}\r\n  \r\n\r\n\r\n\r\n}\r\n\r\nexport default GeneticAlgorithm;\r\n","import NeuralNet from \"./neuralNet\";\r\nimport Vector2d from \"./vector2d\";\r\nimport Parameters from \"./parameters\";\r\nimport TwoDimensionalMatrix from \"./twoDimensionalMatrix\";\r\nimport clamp from \"../utils/clamp\";\r\n\r\nclass Minesweeper {\r\n    /* minesweeper's neural net */\r\n    private brain: NeuralNet;\r\n    /* position of sweeper on screen */\r\n    private position: Vector2d;\r\n    /* vector Mine Sweeper is to aim for, ie \"look at here\" */\r\n    private lookAt: Vector2d;\r\n    /* sweeper's rotation */\r\n    private rotation: number;\r\n    /* velocity of sweeper */\r\n    private velocity: number;\r\n    /* mines discovered */\r\n    private minesFound: number;\r\n    /* size of sweeper's drawing */\r\n    private scale: number;\r\n    /* index of closest mine */\r\n    private closestMine: number;\r\n    /* left track */\r\n    private leftTrack: number;\r\n    /* right track */\r\n    private rightTrack: number;\r\n\r\n    public getNumberOfWeights(): number {\r\n        return this.brain.getNumberOfWeights();\r\n    }\r\n\r\n    constructor() {\r\n        this.brain = new NeuralNet();\r\n        this.position = new Vector2d(Math.random() * Parameters.windowWidth, Math.random() * Parameters.windowHeight);\r\n        this.rotation = Math.random() * 2 * Math.PI;\r\n        this.lookAt = new Vector2d(Math.sin(this.rotation) * -1,Math.cos(this.rotation));\r\n        this.velocity = 0;\r\n        this.minesFound = 0;\r\n        this.scale = Parameters.sweeperScale;\r\n        this.closestMine = 0;\r\n        this.leftTrack = 0.16;\r\n        this.rightTrack = 0.16;\r\n    }\r\n\r\n    /*****\r\n     * reset\r\n     * Resets the sweepers position, fitness and rotation\r\n     * \r\n    */ \r\n    public reset(): void {\r\n        this.position = new Vector2d(Math.random() * Parameters.windowWidth, Math.random() * Parameters.windowHeight);\r\n        this.rotation = Math.random() * 2 * Math.PI;\r\n        this.minesFound = 0;\r\n    }\r\n\r\n    /**\r\n     * worldTransform\r\n     * \r\n     * sets up a translation matrix for the sweeper according to its\r\n     *  scale, rotation and position. Returns the transformed vertices.\r\n     * \r\n     */\r\n    public worldTransform(sweeper:Vector2d[]): void {\r\n        const matTransform = new TwoDimensionalMatrix();\r\n        matTransform.scale(this.scale, this.scale);\r\n        matTransform.translate(this.position.x, this.position.y);\r\n        matTransform.rotate(this.rotation);\r\n        matTransform.transformPoints(sweeper);\r\n    }\r\n\r\n    /**\r\n     * update() \r\n     * First we take sensor readings and feed these into the sweepers brain.\r\n    * The inputs are:\r\n    * A vector to the closest mine (x, y)\r\n    * The sweepers 'look at' vector (x, y)\r\n    * We receive two outputs from the brain: leftTrack & rightTrack.\r\n    * Given a force for each track we calculate the resultant rotation \r\n    * and acceleration and apply to current velocity vector.\r\n    * */\r\n    public update(mines: Vector2d[]): Boolean {\r\n        const inputs: number[] = [];\r\n        const closestMine: Vector2d = this.getClosestMine(mines);\r\n        closestMine.normalize();\r\n        inputs.push(closestMine.x);\r\n        inputs.push(closestMine.y);\r\n        inputs.push(this.lookAt.x);\r\n        inputs.push(this.lookAt.y);\r\n\r\n        const outputs: number[] = this.brain.update(inputs);\r\n\r\n        if (outputs.length !== Parameters.numOutputs) {\r\n            throw new Error(\"Outputs length does not match number of outputs\");\r\n        }\r\n\r\n        this.leftTrack = outputs[0];\r\n        this.rightTrack = outputs[1];\r\n\r\n        let rotForce = this.leftTrack - this.rightTrack;\r\n        rotForce = clamp(rotForce, -Parameters.maxTurnRate, Parameters.maxTurnRate);\r\n        this.rotation += rotForce;\r\n        this.velocity = this.leftTrack + this.rightTrack;\r\n        this.lookAt.x = -Math.sin(this.rotation);\r\n        this.lookAt.y = Math.cos(this.rotation);\r\n        this.position.add(this.lookAt.multiply(this.velocity));\r\n        if (this.position.x < 0) {\r\n            this.position.x = Parameters.windowWidth;\r\n        }\r\n        if (this.position.x > Parameters.windowWidth) {\r\n            this.position.x = 0;\r\n        }\r\n        if (this.position.y < 0) {\r\n            this.position.y = Parameters.windowHeight;\r\n        }\r\n        if (this.position.y > Parameters.windowHeight) {\r\n            this.position.y = 0;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public getClosestMine(mines: Vector2d[]): Vector2d {\r\n        let closestMine = 0;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        for (let i = 0; i < mines.length; i++) {\r\n            const distance = this.position.subtract(mines[i]).magnitude();\r\n            if (distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestMine = i;\r\n            }\r\n        }\r\n        return mines[closestMine];\r\n    }\r\n\r\n    public incrementMinesFound(): void {\r\n        this.minesFound++;\r\n    }\r\n\r\n    public getMinesFound(): number {\r\n        return this.minesFound;\r\n    }\r\n\r\n    public getPosition(): Vector2d {\r\n        return this.position;\r\n    }\r\n    public checkForMine(mines: Vector2d[], size:number): number {\r\n        const distance = this.position.subtract(mines[this.closestMine]).magnitude();\r\n        if (distance < (size + 5)) {\r\n            return this.closestMine;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n\r\n    // accessors\r\n    incrementFitness(): void { this.incrementMinesFound(); }\r\n\r\n\tfitness(){return this.minesFound;}\r\n  \r\n    putWeights(w:number[]){this.brain.putWeights(w);}\r\n\r\n}\r\n\r\nexport default Minesweeper;","import NeuronLayer from \"./neuronLayer\";\r\nimport { dActivationResponse, dBias, iNeuronsPerHiddenLayer, iNumHidden, iNumInputs, iNumOutputs } from \"../config\";\r\n\r\nclass NeuralNet {\r\n  private numInputs: number;\r\n  private numOutputs: number;\r\n  private numHiddenLayers: number;\r\n  private neuronsPerHiddenLayer: number;\r\n  private neuronLayers: NeuronLayer[] = [];\r\n\r\n  constructor(){\r\n    this.numInputs = iNumInputs;\r\n    this.numOutputs = iNumOutputs;\r\n    this.numHiddenLayers = iNumHidden;\r\n    this.neuronsPerHiddenLayer = iNeuronsPerHiddenLayer;\r\n  }\r\n\r\n\r\n  createNet(){\r\n    //create the layers of the network\r\n    if (this.numHiddenLayers > 0){\r\n      //create first hidden layer\r\n      this.neuronLayers.push(new NeuronLayer(this.neuronsPerHiddenLayer, this.numInputs));\r\n      for (let i=0; i<this.numHiddenLayers; i++){\r\n        this.neuronLayers.push(new NeuronLayer(this.neuronsPerHiddenLayer, this.neuronsPerHiddenLayer));\r\n      }\r\n      //create output layer\r\n      this.neuronLayers.push(new NeuronLayer(this.numOutputs, this.neuronsPerHiddenLayer));\r\n    } else {\r\n      //create output layer\r\n      this.neuronLayers.push(new NeuronLayer(this.numOutputs, this.numInputs));\r\n    }\r\n  }\r\n\r\n  //\treturns the total number of weights needed for the net\r\n  getNumberOfWeights():number{\r\n    let weights = 0;\r\n    //for each layer\r\n    for (let i=0; i<this.numHiddenLayers; i++){\r\n      //for each neuron\r\n      for (let j=0; j<this.neuronLayers[i].numNeurons; j++){\r\n        //for each weight\r\n        for (let k=0; k<this.neuronLayers[i].vecNeurons[j].numInputs; k++){\r\n          weights++;\r\n        }\r\n      }\r\n    }\r\n    return weights;\r\n  }\r\n\r\n  //\treturns an array containing the weights\r\n  getWeights(){\r\n    //this will hold the weights\r\n\t  const weights:number[] = [];\r\n    //for each layer\r\n    for (let i=0; i<this.numHiddenLayers; i++){\r\n      //for each neuron\r\n      for (let j=0; j<this.neuronLayers[i].numNeurons; j++){\r\n        //for each weight\r\n        for (let k=0; k<this.neuronLayers[i].vecNeurons[j].numInputs; k++){\r\n          weights.push(this.neuronLayers[i].vecNeurons[j].vecWeight[k]);\r\n        }\r\n      }\r\n    }\r\n    return weights;\r\n  }\r\n  putWeights(weights:number[]){\r\n    let cWeight = 0;\t\r\n    //for each layer\r\n    for (let i=0; i<this.numHiddenLayers; i++){\r\n      //for each neuron\r\n      for (let j=0; j<this.neuronLayers[i].numNeurons; j++){\r\n        //for each weight\r\n        for (let k=0; k<this.neuronLayers[i].vecNeurons[j].numInputs; k++){\r\n          this.neuronLayers[i].vecNeurons[j].vecWeight[k] = weights[cWeight++];\r\n        }\r\n      }\r\n    }\r\n    return;\r\n  }\r\n  update(inputs:number[]):number[]{\r\n    // stores the resultant outputs from each layer\r\n    let outputs:number[] = [];\r\n    let cWeight = 0;\r\n    // first check that we have the correct amount of inputs\r\n    if (inputs.length !== this.numInputs){\r\n      // just return an empty vector if incorrect.\r\n      return outputs;\r\n    }\r\n    // For each layer....\r\n    for (let i=0; i<this.numHiddenLayers; i++){\r\n      if ( i > 0 ){\r\n        inputs = outputs;\r\n      }\r\n      outputs.length = 0;\r\n      cWeight = 0;\r\n      // for each neuron sum the (inputs * corresponding weights).\r\n      // Throw the total at our sigmoid function to get the output.\r\n\r\n      for (let j=0; j<this.neuronLayers[i].numNeurons; j++){\r\n        let netinput = 0;\r\n        this.numInputs = this.neuronLayers[i].vecNeurons[j].numInputs;\r\n        for (let k=0; k<this.numInputs; k++){\r\n          // sum the weights x inputs\r\n          netinput += this.neuronLayers[i].vecNeurons[j].vecWeight[k] * inputs[cWeight++];\r\n        }\r\n        // add in the bias\r\n        netinput += this.neuronLayers[i].vecNeurons[j].vecWeight[this.numInputs-1] * dBias;\r\n        // we can store the outputs from each layer as we generate them.\r\n        // The combined activation is first filtered through the sigmoid\r\n        // function\r\n        outputs.push(this.sigmoid(netinput, dActivationResponse));\r\n        cWeight = 0;\r\n      }\r\n    }\r\n    return outputs;\r\n  }\r\n  sigmoid(netinput: number, response:number):number {\r\n    return ( 1 / ( 1 + Math.exp(-1 * netinput / response)));\r\n  }\r\n}\r\n\r\n export default NeuralNet;\r\n","import Neuron from './neuron';\r\n\r\nclass NeuronLayer {\r\n  //the number of neurons in this layer\r\n  numNeurons: number;\r\n  numInputsPerNeuron: number;\r\n  //the layer of neurons\r\n  vecNeurons: Neuron[] = [];\r\n\r\n  constructor(numNeurons:number, numInputsPerNeuron: number){\r\n    this.numNeurons = numNeurons;\r\n    this.numInputsPerNeuron = numInputsPerNeuron;\r\n    for(let i = 0; i<numNeurons; i++){\r\n      this.vecNeurons.push(new Neuron(this.numInputsPerNeuron));\r\n    }\r\n  }\r\n};\r\n\r\nexport default NeuronLayer;","class Neuron {\r\n  numInputs:number;\r\n  vecWeight:number[] = [];\r\n\r\n\r\n  constructor(numInputs:number) {\r\n    //we need an additional weight for the bias hence the +1\r\n    this.numInputs = numInputs;\r\n    for (let i=0; i<numInputs+1; ++i){\r\n      this.vecWeight.push(Math.random());\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default Neuron;\r\n\r\n","class Parameters {\r\n    /* General parameters */\r\n    static windowWidth = 400;\r\n    static windowHeight = 400;\r\n    static framesPerSecond = 60;\r\n\r\n    /* Used for the neural network */\r\n    static numInputs = 4;\r\n    static numHidden = 1;  \r\n    static neuronsPerHiddenLayer = 6;\r\n    static numOutputs = 2;\r\n    /* for tweeking the sigmoid function */\r\n    static activationResponse = 1;\r\n    /* Bias value */\r\n    static bias = -1;\r\n    /* limits how fast the sweepers can turn */\r\n    static maxTurnRate = 0.3;\r\n    static maxSpeed = 2;\r\n    /* for controlling the size */\r\n    static sweeperScale = 5;\r\n    /* controller parameters */\r\n    static numMines = 40;\r\n    static numSweepers = 30;\r\n    /* number of time steps we allow for each generation to live */\r\n    static numTicks = 2000;\r\n    /* scaling factor for mines */\r\n    static mineScale = 2;\r\n    /* Genetic Algorithim parameters */\r\n    static crossoverRate = 0.7;\r\n    static mutationRate = 0.1;\r\n    /* the maximum amount the ga may mutate each weight by */\r\n    static maxPerturbation = 0.3;\r\n    /* used for elitism */\r\n    static numElite = 4;\r\n    static numCopiesElite = 1\r\n}\r\n\r\nexport default Parameters;","import Vector2d from \"./vector2d\";\r\n\r\n\r\nclass TwoDimensionalMatrix {\r\n    _11!: number;\r\n    _12!: number;\r\n    _13!: number;\r\n    _21!: number;\r\n    _22!: number;\r\n    _23!: number;\r\n    _31!: number;\r\n    _32!: number;\r\n    _33!: number;\r\n\r\n    constructor() {\r\n        this._11 = 0;\r\n        this._12 = 0;\r\n        this._13 = 0;\r\n        this._21 = 0;\r\n        this._22 = 0;\r\n        this._23 = 0;\r\n        this._31 = 0;\r\n        this._32 = 0;\r\n        this._33 = 0;\r\n    }\r\n\r\n    private consumeMatrix(mIn: TwoDimensionalMatrix): void {\r\n        this._11 = mIn._11;\r\n        this._12 = mIn._12;\r\n        this._13 = mIn._13;\r\n        this._21 = mIn._21;\r\n        this._22 = mIn._22;\r\n        this._23 = mIn._23;\r\n        this._31 = mIn._31;\r\n        this._32 = mIn._32;\r\n        this._33 = mIn._33;\r\n    }\r\n\r\n    public TwoDimensionalMatrixMultiply(mIn: TwoDimensionalMatrix): void {\r\n        const mat_temp = new TwoDimensionalMatrix();\r\n        mat_temp._11 = (this._11 * mIn._11) + (this._12 * mIn._21) + (this._13 * mIn._31);\r\n        mat_temp._12 = (this._11 * mIn._12) + (this._12 * mIn._22) + (this._13 * mIn._32);\r\n        mat_temp._13 = (this._11 * mIn._13) + (this._12 * mIn._23) + (this._13 * mIn._33);\r\n        mat_temp._21 = (this._21 * mIn._11) + (this._22 * mIn._21) + (this._23 * mIn._31);\r\n        mat_temp._22 = (this._21 * mIn._12) + (this._22 * mIn._22) + (this._23 * mIn._32);\r\n        mat_temp._23 = (this._21 * mIn._13) + (this._22 * mIn._23) + (this._23 * mIn._33);\r\n        mat_temp._31 = (this._31 * mIn._11) + (this._32 * mIn._21) + (this._33 * mIn._31);\r\n        mat_temp._32 = (this._31 * mIn._12) + (this._32 * mIn._22) + (this._33 * mIn._32);\r\n        mat_temp._33 = (this._31 * mIn._13) + (this._32 * mIn._23) + (this._33 * mIn._33);\r\n        this.consumeMatrix(mat_temp);\r\n    }\r\n\r\n    public createIdentity(): TwoDimensionalMatrix {\r\n        let matrix = new TwoDimensionalMatrix();\r\n        matrix._11 = 1;\r\n        matrix._22 = 1;\r\n        matrix._33 = 1;\r\n        matrix._12 = 0;\r\n        matrix._13 = 0;\r\n        matrix._21 = 0;\r\n        matrix._23 = 0;\r\n        matrix._31 = 0;\r\n        matrix._32 = 0;\r\n        return matrix;\r\n    }\r\n    public translate(x: number, y: number): void {\r\n        let matrix = this.createIdentity();\r\n        matrix._31 = x;\r\n        matrix._32 = y;\r\n        this.TwoDimensionalMatrixMultiply(matrix);\r\n    }\r\n\r\n    public scale(xScale: number, yScale: number): void {\r\n        let matrix = this.createIdentity();\r\n        matrix._11 = xScale;\r\n        matrix._22 = yScale;\r\n        this.TwoDimensionalMatrixMultiply(matrix);\r\n    }\r\n\r\n    public rotate(angle: number): void {\r\n        let matrix = this.createIdentity();\r\n        const sin = Math.sin(angle);\r\n        const cos = Math.cos(angle);\r\n        matrix._11 = cos;\r\n        matrix._12 = sin;\r\n        matrix._21 = -sin;\r\n        matrix._22 = cos;\r\n        this.TwoDimensionalMatrixMultiply(matrix);\r\n    }\r\n\r\n    public transformPoints(points: Vector2d[]): void {\r\n        for (let i = 0; i < points.length; i++) {\r\n            let tempX = (this._11 * points[i].x) + (this._21 * points[i].y) + (this._31);\r\n            let tempY = (this._12 * points[i].x) + (this._22 * points[i].y) + (this._32);\r\n            points[i].x = tempX;\r\n            points[i].y = tempY;\r\n        }\r\n    }\r\n};\r\n\r\nexport default TwoDimensionalMatrix;","\r\n//-------------------------------------Clamp()-----------------------------------------\r\n//\r\n//\tclamps the first argument between the second two\r\n//\r\n//-------------------------------------------------------------------------------------\r\nconst clamp = (num: number, min: number, max: number) => Math.min(Math.max(num, min), max);\r\n\r\nexport default clamp;"],"names":["$6f7c4b99a861fe4c$export$2e2bcd8739ae039","constructor","fps","currentTime","lastTime","nextTime","frameTime","perfCountFreq","timeElapsed","Date","getTime","start","readyForNextFrame","getTimeElapsed","$94f6e316629eca7d$export$2e2bcd8739ae039","a","b","x","y","add","vector","subtract","multiply","multiplier","divide","divisor","magnitude","Math","sqrt","normalize","dot","vector1","vector2","sign","$2bc85bb134c0aae0$export$42a9d1bcccbbcaf9","sort","dFitness","w","vecWeights","length","$2bc85bb134c0aae0$export$2e2bcd8739ae039","popsize","MutRat","CrossRat","numweights","vecPop","iPopSize","dMutationRate","dCrossoverRate","iChromoLength","dTotalFitness","cGeneration","iFittestGenome","dBestFitness","dWorstFitness","dAverageFitness","i","push","j","random","mutate","chromo","getChromoRoulette","theChosenOne","slice","fitnessSoFar","Error","crossover","mum","dad","baby1","baby2","cp","round","epoch","oldPop","reset","calculateBestWorstAvTot","vecNewPop","grabNBest","nBest","numCopies","pop","nB","highestSoFar","lowestSoFar","getChromos","getGeneration","averageFitness","bestFitness","$730cc5316bb92ec7$export$2e2bcd8739ae039","numInputs","vecWeight","$86a107e811c366ae$export$2e2bcd8739ae039","numNeurons","numInputsPerNeuron","vecNeurons","$37b5892f7e409e2f$export$2e2bcd8739ae039","neuronLayers","numOutputs","numHiddenLayers","neuronsPerHiddenLayer","createNet","getNumberOfWeights","weights","k","getWeights","putWeights","cWeight","update","inputs","outputs","netinput","sigmoid","response","exp","$8951c85a05b20536$var$Parameters","_","windowWidth","_1","windowHeight","_2","framesPerSecond","_3","_4","numHidden","_5","_6","_7","activationResponse","_8","bias","_9","maxTurnRate","_10","maxSpeed","_11","sweeperScale","_12","numMines","_13","numSweepers","_14","numTicks","_15","mineScale","_16","crossoverRate","_17","mutationRate","_18","maxPerturbation","_19","numElite","_20","numCopiesElite","$cafaca3b07c4a330$var$TwoDimensionalMatrix","_21","_22","_23","_31","_32","_33","consumeMatrix","mIn","TwoDimensionalMatrixMultiply","mat_temp","createIdentity","matrix","translate","scale","xScale","yScale","rotate","angle","sin","cos","transformPoints","points","tempX","tempY","$e86236eac40c38ae$export$2e2bcd8739ae039","num","min","max","$dc902dc767253299$export$2e2bcd8739ae039","brain","position","rotation","PI","lookAt","velocity","minesFound","closestMine","leftTrack","rightTrack","worldTransform","sweeper","matTransform","mines","getClosestMine","rotForce","closestDistance","Number","MAX_VALUE","distance","incrementMinesFound","getMinesFound","getPosition","checkForMine","size","incrementFitness","fitness","$68677b18c84ba1fc$var$sweeper","Array","$68677b18c84ba1fc$var$mine","$68677b18c84ba1fc$export$2e2bcd8739ae039","vecMines","sweeperVB","mineVB","fastRender","iTick","iGeneration","vecAvFitness","vecBestFitness","canvas","document","createElement","width","height","body","appendChild","numberOfSweepers","numberOfMines","vecThePopulation","vecSweepers","numberOfWeightsInNN","geneticAlgorithm","destroy","render","generationText","ctx","getContext","fillStyle","strokeRect","fill","strokeStyle","lineWidth","font","strokeText","plotStats","beginPath","JSON","parse","stringify","moveTo","vert","lineTo","stroke","closePath","vBuffer","vPos","console","log","grabHit","s","s2","getFastRender","setFastRender","value","fastRenderToggler","$76511dfb7d36bdfc$var$cppMessageSystem","getInstance","instance","messageQueue","pushMessage","message","popMessage","peekMessage","$76511dfb7d36bdfc$export$861edd1ccea2f746","messageProcesser","controller","done","timer","error"],"version":3,"file":"index.js.map"}